"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.aesDecrypt = exports.aesEncrypt = exports.symDecrypt = exports.symEncrypt = void 0;
var utils_1 = require("@noble/ciphers/utils");
var webcrypto_1 = require("@noble/ciphers/webcrypto");
var aes_1 = require("@ecies/ciphers/aes");
var chacha_1 = require("@ecies/ciphers/chacha");
var config_1 = require("../config");
var consts_1 = require("../consts");
var symEncrypt = function (key, plainText) {
    return _exec(_encrypt, key, plainText);
};
exports.symEncrypt = symEncrypt;
var symDecrypt = function (key, cipherText) {
    return _exec(_decrypt, key, cipherText);
};
exports.symDecrypt = symDecrypt;
/** @deprecated - use `symEncrypt` instead. */
exports.aesEncrypt = exports.symEncrypt; // TODO: delete
/** @deprecated - use `symDecrypt` instead. */
exports.aesDecrypt = exports.symDecrypt; // TODO: delete
function _exec(callback, key, data) {
    var algorithm = (0, config_1.symmetricAlgorithm)();
    if (algorithm === "aes-256-gcm") {
        return callback(aes_1.aes256gcm, key, data, (0, config_1.symmetricNonceLength)(), consts_1.AEAD_TAG_LENGTH);
    }
    else if (algorithm === "xchacha20") {
        return callback(chacha_1.xchacha20, key, data, consts_1.XCHACHA20_NONCE_LENGTH, consts_1.AEAD_TAG_LENGTH);
    }
    else if (algorithm === "aes-256-cbc") {
        // NOT RECOMMENDED. There is neither AAD nor AEAD tag in cbc mode
        // aes-256-cbc always uses 16 bytes iv
        return callback(aes_1.aes256cbc, key, data, 16, 0);
    }
    else {
        throw new Error("Not implemented");
    }
}
function _encrypt(func, key, plainText, nonceLength, tagLength) {
    var nonce = (0, webcrypto_1.randomBytes)(nonceLength);
    var cipher = func(key, nonce);
    var ciphered = cipher.encrypt(plainText); // encrypted || tag
    var encrypted = ciphered.subarray(0, ciphered.length - tagLength);
    var tag = ciphered.subarray(ciphered.length - tagLength);
    return (0, utils_1.concatBytes)(nonce, tag, encrypted);
}
function _decrypt(func, key, cipherText, nonceLength, tagLength) {
    var nonceTagLength = nonceLength + tagLength;
    var nonce = cipherText.subarray(0, nonceLength);
    var tag = cipherText.subarray(nonceLength, nonceTagLength);
    var encrypted = cipherText.subarray(nonceTagLength);
    var decipher = func(key, Uint8Array.from(nonce)); // to reset byteOffset
    var ciphered = (0, utils_1.concatBytes)(encrypted, tag);
    return decipher.decrypt(ciphered);
}
